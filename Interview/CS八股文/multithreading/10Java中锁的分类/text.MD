锁的分类
1.1 可重入锁、不可重入锁
Java中提供的synchronized，
ReentrantLock，ReentrantReadWriteLock都是可重入锁
重入: 当前线程获取到A锁，在获取之后尝试再次获取A锁是可以直接拿到的。
不可重入: 当前线程获取到A锁，在获取之后尝试再次获取A锁，无法获取到的，因为A锁被当前线程占用着，需
要等待自己释放锁再获取锁。

1.2 乐观锁、悲观锁
Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是悲观锁
Java中提供的CAS操作，就是乐观锁的一种实现。

悲观锁: 获取不到锁资源时，会将当前线程挂起(进入BLOCKED、WAITING)，线程挂起会涉及到用户态和内
核的太的切换，而这种切换是比较消耗资源的。
。用户态:JVM可以自行执行的指令，不需要借助操作系统执行。
。内核态: JVM不可以自行执行，需要操作系统才可以执行。

乐观锁: 获取不到锁资源，可以再次让CPU调度，重新尝试获取锁资源
Atomic原子性类中，就是基于CAS乐观锁实现的

1.3 公平锁、非公平锁
Java中提供的synoronized只能是非公平锁
Java中提供的ReentrantLock，ReentrantReadWriteLock可以实现公平锁和非公平锁
公平锁: 线程A获取到了锁资源，线程B没有拿到，线程B去排队，
线程C来了，锁被A持有，同时线程B在排队
直接排到B的后面，等待B拿到锁资源或者是B取消后，才可以尝试去竞争锁资源
非公平锁: 线程A获取到了锁资源，线程B没有拿到，线程B去排队,线程C来了，先尝试获取一次锁资源，。
拿到锁资源（A刚好用完锁，正准备唤醒线程B，但还未唤醒B时—）:插队成功。
没有拿到锁资源: 依然要排到B的后面，等待B拿到锁资源或者是B取消后，才可以尝试去竞争锁资源

//version2
公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。
优点：所有的线程都能得到资源，不会饿死在队列中。
缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。

非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。
优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。

1.4 互斥锁、共享锁
Java中提供的synchronized、ReegrantLock是互斥锁。
Java中提供的ReentrantReadWriteLock，有互斥锁也有共享锁
互斥锁: 同一时间点，只会有一个线程持有者当前互斥锁。
共享锁: 同一时间点，当前共享锁可以被多个线程同时持有。